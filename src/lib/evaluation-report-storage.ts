/**
 * Evaluation Report Storage Utility
 *
 * Handles saving and retrieving evaluation reports generated by Dr. Luna Clearwater.
 * Uses Supabase database for primary storage with localStorage as fallback.
 */

import {
  saveEvaluationReportToDB,
  getUserEvaluationReportsFromDB,
  getEvaluationReportByIdFromDB,
  deleteEvaluationReportFromDB,
  hasEvaluationReportsInDB,
  getLatestEvaluationReportFromDB,
  clearAllEvaluationReportsFromDB,
} from './evaluation-report-db';

export interface EvaluationReport {
  user_evaluation_report: {
    report_id: string;
    evaluation_date: string;
    dietitian: string;
    report_version: string;
    user_profile_summary: {
      user_id: string;
      evaluation_completeness: number;
      data_quality_score: number;
      last_updated: string;
    };
    safety_assessment: {
      status: string;
      critical_alerts: Array<{
        type: string;
        severity: string;
        item: string;
        required_action: string;
        hidden_sources: string[];
        cross_contamination_risk: string;
      }>;
      dietary_restrictions: Array<{
        type: string;
        severity: string;
        tolerance_threshold: string;
        safe_alternatives: string[];
        enzyme_supplementation: string;
      }>;
      medical_considerations: Array<{
        condition: string;
        nutritional_priority: string;
        key_strategies: string[];
        monitoring_markers: string[];
      }>;
    };
    personalization_matrix: {
      skill_profile: {
        current_level: string;
        confidence_score: number;
        growth_trajectory: string;
        recommended_techniques: string[];
        advancement_timeline: string;
      };
      time_analysis: {
        available_time_per_meal: number;
        time_utilization_efficiency: number;
        optimization_opportunities: string[];
        quick_meal_quota: string;
      };
      equipment_optimization: {
        utilization_rate: number;
        underused_tools: string[];
        missing_beneficial_tools: string[];
        technique_adaptations: string;
      };
      cultural_preferences: {
        primary_cuisines: string[];
        flavor_profile_affinity: string;
        spice_tolerance_calibration: number;
        fusion_receptiveness: string;
      };
      ingredient_landscape: {
        embrace_list: string[];
        avoid_list: string[];
        exploration_candidates: string[];
        substitution_success_rate: number;
      };
    };
    nutritional_analysis: {
      current_status: {
        overall_diet_quality_score: number;
        nutritional_completeness: number;
        anti_inflammatory_index: number;
        gut_health_score: number;
        metabolic_health_score: number;
      };
      deficiency_risks: Array<{
        nutrient: string;
        risk_level: string;
        current_intake_estimate: string;
        food_sources: string[];
        supplementation_consideration: string;
      }>;
      optimization_priorities: Array<{
        priority: number;
        focus: string;
        impact_score: number;
        implementation_difficulty: string;
      }>;
    };
    personalized_recommendations: {
      immediate_actions: Array<{
        action: string;
        description: string;
        expected_benefit: string;
        difficulty: string;
        resources_provided: string[];
      }>;
      weekly_structure: {
        meal_framework: {
          breakfast_template: string;
          lunch_template: string;
          dinner_template: string;
          snack_strategy: string;
        };
        cuisine_rotation: {
          monday: string;
          tuesday: string;
          wednesday: string;
          thursday: string;
          friday: string;
          weekend: string;
        };
      };
      progressive_challenges: Array<{
        week_1_4: string;
        week_5_8: string;
        week_9_12: string;
      }>;
    };
    meal_suggestions: {
      signature_recipes: Array<{
        name: string;
        prep_time: number;
        skill_match: number;
        health_impact_score: number;
        customization_notes: string;
        allergen_safe: boolean;
      }>;
      quick_options: string[];
      batch_cooking_priorities: string[];
    };
    progress_tracking: {
      key_metrics: Array<{
        metric: string;
        baseline: string;
        target: string;
        reassessment: string;
      }>;
      milestone_markers: Array<{
        week_2: string;
        week_4: string;
        week_8: string;
        week_12: string;
      }>;
    };
    risk_mitigation: {
      adherence_barriers: Array<{
        barrier: string;
        mitigation_strategy: string;
        backup_plan: string;
      }>;
      safety_reminders: string[];
    };
    support_resources: {
      education_modules: string[];
      tools_provided: string[];
      community_connections: string[];
    };
    next_steps: {
      immediate_72_hours: string[];
      week_1_goals: string[];
      week_1_objectives: string[];
    };
    professional_notes: {
      strengths_observed: string;
      growth_opportunities: string;
      collaboration_recommendations: string;
      reassessment_schedule: string;
    };
    report_metadata: {
      confidence_level: number;
      data_completeness: number;
      personalization_depth: string;
      evidence_base: string;
      last_literature_review: string;
      next_update_recommended: string;
    };
  };
}

/**
 * Save an evaluation report for a user
 */
export const saveEvaluationReport = async (
  userId: string,
  report: EvaluationReport
): Promise<void> => {
  try {
    // Try to save to database first
    await saveEvaluationReportToDB(userId, report);

    // Also save to localStorage as backup
    const storageKey = `evaluation_reports_${userId}`;
    const existingReports = localStorage.getItem(storageKey);

    let reports: EvaluationReport[] = [];
    if (existingReports) {
      reports = JSON.parse(existingReports);
    }

    // Check if this report already exists (by report_id)
    const existingIndex = reports.findIndex(
      (r) =>
        r.user_evaluation_report.report_id ===
        report.user_evaluation_report.report_id
    );

    if (existingIndex >= 0) {
      // Update existing report
      reports[existingIndex] = report;
    } else {
      // Add new report
      reports.push(report);
    }

    // Sort by evaluation date (newest first)
    reports.sort(
      (a, b) =>
        new Date(b.user_evaluation_report.evaluation_date).getTime() -
        new Date(a.user_evaluation_report.evaluation_date).getTime()
    );

    localStorage.setItem(storageKey, JSON.stringify(reports));

    console.log(
      `Evaluation report saved for user ${userId}:`,
      report.user_evaluation_report.report_id
    );
  } catch (error) {
    console.error('Error saving evaluation report:', error);
    throw new Error('Failed to save evaluation report');
  }
};

/**
 * Get all evaluation reports for a user
 */
export const getUserEvaluationReports = async (
  userId: string
): Promise<EvaluationReport[]> => {
  try {
    // Try to get from database first
    const dbReports = await getUserEvaluationReportsFromDB(userId);

    if (dbReports.length > 0) {
      return dbReports;
    }

    // Fallback to localStorage
    const storageKey = `evaluation_reports_${userId}`;
    const storedReports = localStorage.getItem(storageKey);

    if (!storedReports) {
      return [];
    }

    const reports: EvaluationReport[] = JSON.parse(storedReports);

    // Sort by evaluation date (newest first)
    return reports.sort(
      (a, b) =>
        new Date(b.user_evaluation_report.evaluation_date).getTime() -
        new Date(a.user_evaluation_report.evaluation_date).getTime()
    );
  } catch (error) {
    console.error('Error loading evaluation reports:', error);
    return [];
  }
};

/**
 * Get a specific evaluation report by ID
 */
export const getEvaluationReportById = async (
  userId: string,
  reportId: string
): Promise<EvaluationReport | null> => {
  try {
    // Try to get from database first
    const dbReport = await getEvaluationReportByIdFromDB(userId, reportId);
    if (dbReport) {
      return dbReport;
    }

    // Fallback to localStorage
    const reports = await getUserEvaluationReports(userId);
    return (
      reports.find(
        (report) => report.user_evaluation_report.report_id === reportId
      ) || null
    );
  } catch (error) {
    console.error('Error loading evaluation report:', error);
    return null;
  }
};

/**
 * Delete an evaluation report
 */
export const deleteEvaluationReport = async (
  userId: string,
  reportId: string
): Promise<boolean> => {
  try {
    // Try to delete from database first
    const dbSuccess = await deleteEvaluationReportFromDB(userId, reportId);

    // Also delete from localStorage
    const storageKey = `evaluation_reports_${userId}`;
    const existingReports = localStorage.getItem(storageKey);

    if (existingReports) {
      let reports: EvaluationReport[] = JSON.parse(existingReports);
      reports = reports.filter(
        (report) => report.user_evaluation_report.report_id !== reportId
      );
      localStorage.setItem(storageKey, JSON.stringify(reports));
    }

    console.log(`Evaluation report deleted for user ${userId}:`, reportId);
    return dbSuccess;
  } catch (error) {
    console.error('Error deleting evaluation report:', error);
    return false;
  }
};

/**
 * Clear all evaluation reports for a user from both database and localStorage
 */
export const clearAllEvaluationReports = async (
  userId: string
): Promise<boolean> => {
  try {
    // Clear from database first
    const dbSuccess = await clearAllEvaluationReportsFromDB(userId);

    // Clear from localStorage
    const storageKey = `evaluation_reports_${userId}`;
    localStorage.removeItem(storageKey);

    if (dbSuccess) {
      console.log(`All evaluation reports cleared for user ${userId}`);
      return true;
    } else {
      console.warn(
        `Database clear failed, but localStorage cleared for user ${userId}`
      );
      return false;
    }
  } catch (error) {
    console.error('Error clearing evaluation reports:', error);
    return false;
  }
};

/**
 * Check if a user has any evaluation reports
 */
export const hasEvaluationReports = async (
  userId: string
): Promise<boolean> => {
  try {
    // Try database first
    const dbHasReports = await hasEvaluationReportsInDB(userId);
    if (dbHasReports) {
      return true;
    }

    // Fallback to localStorage
    const reports = await getUserEvaluationReports(userId);
    return reports.length > 0;
  } catch (error) {
    console.error('Error checking evaluation reports:', error);
    return false;
  }
};

/**
 * Get the most recent evaluation report for a user
 */
export const getLatestEvaluationReport = async (
  userId: string
): Promise<EvaluationReport | null> => {
  try {
    // Try database first
    const dbReport = await getLatestEvaluationReportFromDB(userId);
    if (dbReport) {
      return dbReport;
    }

    // Fallback to localStorage
    const reports = await getUserEvaluationReports(userId);
    return reports.length > 0 ? reports[0] : null;
  } catch (error) {
    console.error('Error getting latest evaluation report:', error);
    return null;
  }
};

/**
 * Export evaluation report as JSON file
 */
export const exportEvaluationReport = (
  report: EvaluationReport,
  filename?: string
): void => {
  try {
    const dataStr = JSON.stringify(report, null, 2);
    const dataBlob = new Blob([dataStr], { type: 'application/json' });
    const url = URL.createObjectURL(dataBlob);

    const link = document.createElement('a');
    link.href = url;
    link.download =
      filename ||
      `evaluation_report_${report.user_evaluation_report.report_id}.json`;
    link.click();

    URL.revokeObjectURL(url);
  } catch (error) {
    console.error('Error exporting evaluation report:', error);
    throw new Error('Failed to export evaluation report');
  }
};

/**
 * Import evaluation report from JSON file
 */
export const importEvaluationReport = async (
  file: File
): Promise<EvaluationReport> => {
  return new Promise((resolve, reject) => {
    try {
      const reader = new FileReader();

      reader.onload = (event) => {
        try {
          const content = event.target?.result as string;
          const report: EvaluationReport = JSON.parse(content);

          // Basic validation
          if (
            !report.user_evaluation_report ||
            !report.user_evaluation_report.report_id
          ) {
            throw new Error('Invalid evaluation report format');
          }

          resolve(report);
        } catch {
          reject(new Error('Invalid JSON file'));
        }
      };

      reader.onerror = () => {
        reject(new Error('Failed to read file'));
      };

      reader.readAsText(file);
    } catch {
      reject(new Error('Failed to process file'));
    }
  });
};
